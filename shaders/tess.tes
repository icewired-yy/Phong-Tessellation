#version 410 core

layout (triangles, equal_spacing, ccw) in;

in vec3 tcs_pos[];
in vec3 tcs_normal[];

out vec3 te_pos_world;
out vec3 te_normal_world;

uniform mat4 model;
uniform mat4 view;
uniform mat4 proj;
uniform float shapeFactor;

// Orthogonal projection of point q onto a plane defined by point p and normal n
vec3 project_on_plane(vec3 q, vec3 p, vec3 n)
{
    return q - dot(q - p, n) * n;
}

void main()
{
    // Get barycentric coordinates
    vec3 b = gl_TessCoord;

    // 1. Linearly interpolate position and normal (Eq. 1 & 2)
    vec3 p = b.x * tcs_pos[0] + b.y * tcs_pos[1] + b.z * tcs_pos[2];
    vec3 n = normalize(b.x * tcs_normal[0] + b.y * tcs_normal[1] + b.z * tcs_normal[2]);

    // 2. Project p onto the tangent planes of the three control points
    vec3 p0_proj = project_on_plane(p, tcs_pos[0], tcs_normal[0]);
    vec3 p1_proj = project_on_plane(p, tcs_pos[1], tcs_normal[1]);
    vec3 p2_proj = project_on_plane(p, tcs_pos[2], tcs_normal[2]);

    // 3. Interpolate the projected points (Eq. 3)
    vec3 p_star = b.x * p0_proj + b.y * p1_proj + b.z * p2_proj;

    // 4. Blend between linear and projected position using shapeFactor (Eq. 4)
    vec3 final_p_model = mix(p, p_star, shapeFactor);

    // --- Transformations for lighting and projection ---
    // Transform final position and normal to world space
    te_pos_world = vec3(model * vec4(final_p_model, 1.0));
    te_normal_world = normalize(mat3(transpose(inverse(model))) * n);
    
    // Final position for rasterization
    gl_Position = proj * view * vec4(te_pos_world, 1.0);
}